1. 虚拟机历史
2. [Java内存区域](#java%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f)
3. 垃圾检测
4. 垃圾回收算法
5. 垃圾收集器
# 虚拟机历史
jdk 1.0  Classic VM 纯解释器方式
<br> jdk 1.2  默认Classic VM 备用 HotSpot VM
<br> jdk 1.3  默认HotSpot VM 备用 Classic VM

# Java内存区域

1. 程序计数器(Program Counter Register)
> 为每个线程私有 <br>
> 执行Java方法时，记录的是正在执行的虚拟机字节码指令的地址 <br>
> 如果是native方法，为空 <br>
> 可以帮助线程切换的时候，保留现场信息 <br>
> 不会出现 OOM
2. Java虚拟机栈(Java Virtual Machine Stacks)
> 线程私有
> <br>Java方法执行的内存模型
> <br>存放着栈帧，每个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等
> <br>每个方法从被调用到结束，对应着一个栈帧在虚拟机中入栈到出栈
> <br>可以设置为可动态扩展，如果动态扩展失败，报错 OOM
> <br>可以设置静态大小，如果线程请求的栈深度超过了这个大小，报错 StackOverflowError
3. 本地方法栈(native Method Stack)
> <br>和虚拟机栈类似，但是该区域是为本地方法(native修饰的方法)所用
4. Java堆(java Heap)
> 线程共享
> <br>存放对象的实例，几乎所有的对象实例在此分配
> <br>逻辑连续
> <br>可以设置静态大小或者动态扩展
> <br>当分配的内存大于静态设置的大小，或者堆无法扩展时，报错 OOM       
5. 方法区(Method Area)
> 线程共享
> <br>存储已被虚拟机加载的类信息、常量、静态变量等
> <br>规范中属于堆的一部分
> <br>俗称的永久代

# 垃圾检测
程序计数器、虚拟机栈、本地方法栈随着线程的产生而产生，随着线程的结束而结束，所以进行垃圾回收的主要是内存中的堆部分
## 垃圾检测的方法
1. 什么是垃圾
> 当一个对象实例在未来不会被使用时，就可以视为垃圾
2. 引用计数法（弃用）
> 原理：每个对象实例维系一个计数器，代表有多少个引用指向该对象。当该计数器为零时，表示当前对象已经没有被引用，就可以视为垃圾。
> <br> 问题：如果存在循环引用，就会产生内存溢出。
> <br> 例子：在一方法中有如下代码
> <br> Obj obj1 = new Obj();
> <br> Obj obj2 = new Obj();
> <br> obj1.obj = obj2;
> <br> obj2.obj = obj1;
> <br> obj1 = obj2 = null;
> <br> // 下面的gc中，obj的两个实例都不会被回收
> <br> System.gc();
3. 可达性分析算法
> <br> 可以将一个Java程序中的对象通过引用关系建立一个森林（多个多叉树）
> <br> 例子：如果obj1中有一个引用指向obj2，那么就可以建立obj1-->obj2的关系
> <br> 然后依据多叉树的根节点对树进行垃圾分类，能够找出所有的垃圾了
> <br> 可以作为判断存活对象的根节点有：
> <br> 1、虚拟机栈（栈帧中的本地变量表）中引用的对象
> <br> 2、方法区中类静态属性引用的对象
> <br> 3、方法区中常量引用的对象
> <br> 4、本地方法栈中JNI（native方法）引用的对象
4. 方法区的回收
> 可以被回收的时机
> <br> 1、该类的所有实例全被回收
> <br> 2、加载该类的ClassLoader已经被回收
> <br> 3、该类的Class对象没有在任何地方被引用
> <br> 
> <br> -Xnoclassgc参数可以设置满足时机时，进不进行回收，默认不回收
> 
5. 注意事项
> 对象实例的finalize()最多只会被执行一次

# 垃圾回收的算法
1. 标记-清除算法
<br> 后面两个算法的基础 
<br> 原理：分两个步骤，第一步运用垃圾检测，对垃圾进行标记，第二步，进行垃圾清理
<br> 缺点：效率低下、会产生内存碎片
2. 复制算法
<br>原理：将新生代分为3个区域，一个Eden区和两个Survivor区，新的对象在Eden区中产生，进行垃圾收集时，将Eden区和一个Survivor区中的所有存活的对象复制进另外的一个Survivor区中(默认一个Eden区=8个Survivor区)。
<br>优点：实现简单，运行高效。
<br>缺点：存在着空间的浪费。当存活对象超过了Survivor区的大小会出现问题，通常的解决方式，是使用年老代的空间做担保，将多的对象存入年老代。
3. 标记-整理算法  
原理：