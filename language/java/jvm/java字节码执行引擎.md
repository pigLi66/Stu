## java字节码执行引擎

### 运行时的栈帧结构

> 存储了方法的局部变量表、操作数栈、动态连接、和方法的返回地址等，一个方法在编译时即可确定局部变量表和操作数栈大小

对于执行引擎来讲，只有栈顶的方法是处于运行状态，被称为当前栈帧，所关联的方法被叫做当前方法

1. 局部变量表

局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量（在Code属性的max_locals数据项中确定了最大容量）

**最小单位：变量槽**

方法表中，第0位索引默认是this的引用（静态方法除外）。

局部变量表的变量槽是可以重用的。例如：不同代码块中的变量

局部变量表的引用被作为GC Roots判断垃圾的依据，所以手动将对象设为null 在某些情况下可以让gc尽快的回收。

2. 操作数栈

操作数栈的最大深度在编译时被写入Code属性的max_stacks中

3. 动态连接

每个栈帧都包含一个指向运行时常量池[插图]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

4. 方法返回地址

方法的退出方式：程序正常执行，遇到return或者产生了异常，并且没有被捕获。

正常返回时：主调方法的PC计数器的值作为返回地址，栈帧中可能保存了该值。虚拟机可能会把返回值压入调用方法的操作数栈。

异常时： 返回地址通过异常处理器表确定，栈帧中一般不会保存该内容。

--------

### 方法调用

一切方法调用在Class文件里面存储的只是符号引用，而不是实际运行时内存布局中的入口地址（直接引用），只有在类加载或者运行期间才会确定目标方法的直接引用。

1. 解析

如果方法在程序运行之前就有一个确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，那么在类加载的解析阶段，会将这个方法的符号引用转化为直接引用。这类方法的调用被称为解析。

只要能被invokestatic和invokespecia指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言中包括静态方法、私有方法、实例构造器、父类方法，4种。

final修饰的方法虽然被invokevirtual指令调用，但是可以在解析阶段确定唯一调用的版本。（版本遗留问题）

上述的5种方法被统称为非虚方法，其他的统称为虚方法。

2. 分派

- 静态分派

依赖静态类型决定方法的执行版本的分派动作，被称为静态分配。它由编译器确定调用的方法的版本（因此可以归为解析）。包括方法重载等。

``` java
Object o = new String();
```

在上面的代码中，Object被称为变量的静态类型（外观类型），String被称为变量的实际类型（运行时的类型），这两个类型在程序中都可能发生变化，静态类型的最终值可以在编译器确定（通过强转），实际类型在对象的运行时才会确定。

``` java
Object o = new String();
((String)o).toString() // 实际类型转换为String
o = new Object(); // 实际类型的变换
```

在调用重载的方法时，是由编译器通过参数的静态类型确定具体调用的是哪一个重载方法（编译阶段只能确定方法的静态类型）。

在方法重载时出现装箱时，以char做参数，会出现char>int>long>float>double>包装类>包装类的父类，调用关系

- 动态分派

以来动态类型决定方法的执行的分派动作，被称为动态分配。

3. 单分派和多分派

按照分派的依据有多少宗量，分为单分派和多分派。

静态分配属于多分派，动态分派属于单分派

4. 虚拟机动态分派的实现

基于性能考虑，jvm一般会通过构建虚方法表和接口方法表的方式加快速度，通过使用虚方法表索引代替元素据查找以提高性能。

----

### 动态类型语言支持

**动态类型语言**：类型检查的主体过程是在运行期而不是编译器进行

**java.lang.invoke** jdk7时加入的JSR292的一个组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为方法句柄（Method Handle）

Reflection是在模拟Java代码层面的方法调用，而MethodHandle是模拟字节码层面的方法调用

**invokedynamic指令** JDK7中为了更好的支持动态类型语言，引入的第五条方法调用的字节码指令。

该指令的第一个参数是CONSTANT_InvokeDynamic_info，从这个常量中可以得到引导方法(固定参数，返回值是java.lang.invoke.CallSite对象)、方法类型、名称。

通过第CONSTANT_InvokeDynamic_info常量，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上。